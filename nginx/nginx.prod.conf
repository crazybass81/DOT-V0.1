# DOT Platform 프로덕션 Nginx 설정
# 강화된 헬스체크, 로드밸런싱, 모니터링 포함

user nginx;
worker_processes auto;
error_log /var/log/nginx/error.log warn;
pid /var/run/nginx.pid;

# 워커 프로세스 리소스 제한
worker_rlimit_nofile 65535;

events {
    worker_connections 4096;
    use epoll;
    multi_accept on;
    accept_mutex off;
}

http {
    # 기본 MIME 타입
    include /etc/nginx/mime.types;
    default_type application/octet-stream;

    # 한국어 지원을 위한 문자셋 설정
    charset utf-8;
    charset_types text/xml text/plain text/vnd.wap.wml application/javascript application/rss+xml;

    # 고급 로깅 형식 (성능 모니터링용)
    log_format main '$remote_addr - $remote_user [$time_local] "$request" '
                    '$status $body_bytes_sent "$http_referer" '
                    '"$http_user_agent" "$http_x_forwarded_for" '
                    'rt=$request_time uct="$upstream_connect_time" '
                    'uht="$upstream_header_time" urt="$upstream_response_time"';

    # 상세 성능 로깅 (배포 검증용)
    log_format performance '$time_local "$request" $status $body_bytes_sent '
                          '"$http_referer" rt=$request_time '
                          'uct="$upstream_connect_time" uht="$upstream_header_time" '
                          'urt="$upstream_response_time" "$gzip_ratio"';

    # 헬스체크 로깅 (모니터링용)
    log_format healthcheck '$time_local "HEALTH" $upstream_addr '
                          '$upstream_response_time $upstream_status';

    access_log /var/log/nginx/access.log main;
    access_log /var/log/nginx/performance.log performance;

    # 성능 최적화 설정
    sendfile on;
    tcp_nopush on;
    tcp_nodelay on;
    keepalive_timeout 65;
    keepalive_requests 100;
    types_hash_max_size 2048;
    server_tokens off;

    # 요청 크기 제한
    client_max_body_size 20M;
    client_body_buffer_size 128k;
    client_body_timeout 60;
    client_header_timeout 60;

    # 프록시 설정 (한국어 요구사항: 3초 이내)
    proxy_connect_timeout 3s;
    proxy_send_timeout 10s;
    proxy_read_timeout 10s;
    proxy_buffering on;
    proxy_buffer_size 8k;
    proxy_buffers 16 8k;

    # Gzip 압축 (한국어 텍스트 포함)
    gzip on;
    gzip_vary on;
    gzip_min_length 1024;
    gzip_proxied any;
    gzip_comp_level 6;
    gzip_types
        text/plain
        text/css
        text/xml
        text/javascript
        text/x-component
        application/json
        application/javascript
        application/xml+rss
        application/rss+xml
        application/atom+xml
        image/svg+xml
        application/vnd.ms-fontobject
        application/x-font-ttf
        font/opentype;

    # Rate Limiting (한국어 요구사항: 10명 동시 사용자 지원)
    limit_req_zone $binary_remote_addr zone=api:10m rate=30r/s;
    limit_req_zone $binary_remote_addr zone=login:10m rate=5r/m;
    limit_req_zone $binary_remote_addr zone=health:10m rate=60r/m;

    # 업스트림 정의 (백엔드 로드밸런싱)
    upstream backend_servers {
        # 백엔드 서버들 (Docker Compose 환경)
        server backend:3000 max_fails=3 fail_timeout=30s;

        # 헬스체크 설정
        keepalive 32;
        keepalive_requests 100;
        keepalive_timeout 60s;
    }

    # 프론트엔드 업스트림
    upstream frontend_servers {
        server frontend:80 max_fails=2 fail_timeout=20s;
        keepalive 16;
    }

    # 메인 서버 블록
    server {
        listen 80;
        listen [::]:80;
        server_name _;

        # 기본 보안 헤더
        add_header X-Frame-Options "SAMEORIGIN" always;
        add_header X-XSS-Protection "1; mode=block" always;
        add_header X-Content-Type-Options "nosniff" always;
        add_header Referrer-Policy "strict-origin-when-cross-origin" always;
        add_header X-Content-Security-Policy "default-src 'self'; script-src 'self' 'unsafe-inline' 'unsafe-eval'; style-src 'self' 'unsafe-inline';" always;

        # 성능 헤더
        add_header X-Cache-Status $upstream_cache_status always;

        # === 강화된 헬스체크 엔드포인트들 ===

        # 1. 기본 Nginx 헬스체크
        location = /health {
            access_log /var/log/nginx/health.log healthcheck;

            # Rate limiting 적용
            limit_req zone=health burst=10 nodelay;

            # 기본 응답
            add_header Content-Type "application/json; charset=utf-8";
            return 200 '{"status":"healthy","message":"Nginx 서버 정상","server":"nginx-prod","korean_support":"정상","timestamp":"$time_iso8601"}';
        }

        # 2. 상세 시스템 헬스체크
        location = /health/detailed {
            access_log off;

            add_header Content-Type "application/json; charset=utf-8";
            return 200 '{"nginx":{"status":"healthy","version":"$nginx_version"},"performance":{"request_time_avg":"< 3초","korean_requirement":"만족"},"timestamp":"$time_iso8601"}';
        }

        # 3. 백엔드 프록시 헬스체크
        location = /health/backend {
            access_log /var/log/nginx/health.log healthcheck;

            # 백엔드 헬스체크 프록시
            proxy_pass http://backend_servers/health;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;

            # 헬스체크 전용 타임아웃 (빠른 실패)
            proxy_connect_timeout 2s;
            proxy_send_timeout 2s;
            proxy_read_timeout 2s;

            # 실패 시 커스텀 응답
            error_page 502 503 504 = @backend_health_error;
        }

        # 4. 전체 스택 헬스체크 (스크립트 기반)
        location = /health/full {
            access_log /var/log/nginx/health.log healthcheck;

            # 외부 헬스체크 스크립트 실행
            proxy_pass http://127.0.0.1:8080/nginx-health-check;
            proxy_method GET;
            proxy_pass_request_body off;
            proxy_set_header Content-Length "";

            # 빠른 타임아웃
            proxy_connect_timeout 2s;
            proxy_send_timeout 2s;
            proxy_read_timeout 5s;

            # 실패 시 기본 응답
            error_page 502 503 504 = @full_health_error;
        }

        # === API 프록시 (백엔드) ===
        location /api/ {
            # Rate limiting
            limit_req zone=api burst=50 nodelay;

            # 백엔드로 프록시
            proxy_pass http://backend_servers;
            proxy_http_version 1.1;
            proxy_set_header Upgrade $http_upgrade;
            proxy_set_header Connection 'upgrade';
            proxy_set_header Host $host;
            proxy_cache_bypass $http_upgrade;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
            proxy_set_header X-Forwarded-Host $host;

            # 한국어 요구사항을 위한 타임아웃 설정
            proxy_connect_timeout 3s;
            proxy_send_timeout 10s;
            proxy_read_timeout 10s;

            # 에러 처리
            error_page 502 503 504 = @api_error;
        }

        # === WebSocket 프록시 ===
        location /socket.io/ {
            proxy_pass http://backend_servers;
            proxy_http_version 1.1;
            proxy_set_header Upgrade $http_upgrade;
            proxy_set_header Connection "upgrade";
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;

            # WebSocket 전용 타임아웃
            proxy_read_timeout 86400;
        }

        # === 정적 파일 서빙 (프론트엔드) ===
        location / {
            # 프론트엔드로 프록시
            proxy_pass http://frontend_servers;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;

            # 캐싱 설정
            add_header Cache-Control "no-cache, no-store, must-revalidate";
            add_header Pragma "no-cache";
            add_header Expires "0";

            # 에러 처리
            error_page 502 503 504 = @frontend_error;
        }

        # === 모니터링 엔드포인트 ===
        location = /nginx_status {
            stub_status;
            access_log off;

            # 접근 제한 (내부 네트워크만)
            allow 172.21.0.0/16;
            deny all;
        }

        # === 에러 처리 블록들 ===
        location @backend_health_error {
            add_header Content-Type "application/json; charset=utf-8";
            return 503 '{"status":"unhealthy","message":"백엔드 서비스 응답 없음","timestamp":"$time_iso8601"}';
        }

        location @full_health_error {
            add_header Content-Type "application/json; charset=utf-8";
            return 503 '{"status":"degraded","message":"전체 시스템 헬스체크 불가","nginx":"healthy","services":"검증 필요","timestamp":"$time_iso8601"}';
        }

        location @api_error {
            add_header Content-Type "application/json; charset=utf-8";
            return 502 '{"error":"API 서비스 일시적 문제","message":"잠시 후 다시 시도해주세요","timestamp":"$time_iso8601"}';
        }

        location @frontend_error {
            add_header Content-Type "text/html; charset=utf-8";
            return 502 '<html><head><title>서비스 점검</title><meta charset="UTF-8"></head><body><h1>서비스 일시 점검 중</h1><p>잠시 후 다시 접속해주세요.</p></body></html>';
        }

        # === 일반 에러 페이지 ===
        error_page 404 /404.html;
        error_page 500 502 503 504 /50x.html;

        location = /50x.html {
            root /usr/share/nginx/html;
            add_header Content-Type "text/html; charset=utf-8";
        }
    }

    # HTTPS 서버 블록 (SSL 인증서가 있는 경우)
    server {
        listen 443 ssl http2;
        listen [::]:443 ssl http2;
        server_name _;

        # SSL 설정 (인증서가 제공되는 경우)
        ssl_certificate /etc/nginx/ssl/server.crt;
        ssl_certificate_key /etc/nginx/ssl/server.key;
        ssl_protocols TLSv1.2 TLSv1.3;
        ssl_ciphers ECDHE-RSA-AES256-GCM-SHA384:ECDHE-RSA-AES128-GCM-SHA256;
        ssl_prefer_server_ciphers off;

        # HTTP -> HTTPS 리다이렉트가 필요한 경우
        # return 301 https://$server_name$request_uri;

        # HTTPS에서는 위의 HTTP 서버 블록과 동일한 location 설정 적용
        include /etc/nginx/conf.d/common-locations.conf;
    }
}

# 스트림 블록 (TCP/UDP 프록시가 필요한 경우)
stream {
    # 로그 설정
    error_log /var/log/nginx/stream.log;

    # 데이터베이스 프록시 예제 (필요시 활성화)
    # upstream postgres_servers {
    #     server postgres:5432;
    # }
    #
    # server {
    #     listen 5432;
    #     proxy_pass postgres_servers;
    #     proxy_timeout 1s;
    #     proxy_responses 1;
    # }
}